from collections import defaultdict

def compute_first(grammar):
    first = defaultdict(set)

    def first_of(symbol):
        if symbol in first:
            return first[symbol]
        
        if not symbol.isupper():
            return {symbol}

        for production in grammar[symbol]:
            for char in production.split():
                char_first = first_of(char)
                first[symbol].update(char_first - {'epsilon'})
                
                if 'epsilon' not in char_first:
                    break
            else:
                first[symbol].add('epsilon')
        
        return first[symbol]

    for non_terminal in grammar:
        first_of(non_terminal)
    
    return first

def compute_follow(grammar, start_symbol, first):
    follow = defaultdict(set)
    follow[start_symbol].add('$')

    def follow_of():
        for lhs, productions in grammar.items():
            for production in productions:
                symbols = production.split()
                trailer = follow[lhs].copy()
                
                for i in range(len(symbols) - 1, -1, -1):
                    symbol = symbols[i]
                    
                    if symbol.isupper():
                        follow[symbol].update(trailer)
                        
                        if 'epsilon' in first[symbol]:
                            trailer.update(first[symbol] - {'epsilon'})
                        else:
                            trailer = first[symbol]
                    else:
                        trailer = {symbol}

    for _ in range(len(grammar)):
        follow_of()

    return follow

# Input grammar from user
print("Enter the grammar productions (one per line). Use 'epsilon' for epsilon. Enter a blank line to finish.")
grammar = {}
while True:
    line = input().strip()
    if not line:
        break
    lhs, rhs = line.split('->')
    lhs = lhs.strip()
    rhs = [prod.strip() for prod in rhs.split('|')]
    grammar[lhs] = rhs

# Input start symbol
start_symbol = input("Enter the start symbol: ").strip()

# Compute FIRST and FOLLOW sets
first_sets = compute_first(grammar)
follow_sets = compute_follow(grammar, start_symbol, first_sets)

# Print results
print("\nFIRST sets:")
for non_terminal in grammar:
    print(f"FIRST({non_terminal}) = {first_sets[non_terminal]}")

print("\nFOLLOW sets:")
for non_terminal in grammar:
    print(f"FOLLOW({non_terminal}) = {follow_sets[non_terminal]}")
----------------------------------------------------------------------------------------------------------------------------------------
from collections import defaultdict

def compute_first(grammar):
    first = defaultdict(set)

    def first_of(symbol, visited=set()):
        if symbol in first:
            return first[symbol]

        if not symbol.isupper():  # Terminal
            return {symbol}

        if symbol in visited:
            return set()

        visited.add(symbol)

        for production in grammar[symbol]:
            for char in production:
                char_first = first_of(char, visited.copy())
                first[symbol].update(char_first - {'ε'})

                if 'ε' not in char_first:
                    break
            else:
                first[symbol].add('ε')

        return first[symbol]

    for non_terminal in grammar:
        first_of(non_terminal)

    return first

def compute_follow(grammar, start_symbol, first):
    follow = defaultdict(set)
    follow[start_symbol].add('$')

    changed = True
    while changed:
        changed = False
        for lhs, productions in grammar.items():
            for production in productions:
                trailer = follow[lhs].copy()

                for i in range(len(production) - 1, -1, -1):
                    symbol = production[i]

                    if symbol.isupper():
                        if not follow[symbol].issuperset(trailer):
                            follow[symbol].update(trailer)
                            changed = True

                        if 'ε' in first[symbol]:
                            trailer.update(first[symbol] - {'ε'})
                        else:
                            trailer = first[symbol]
                    else:
                        trailer = {symbol}

    return follow

def construct_ll1_table(grammar, first, follow):
    table = defaultdict(dict)

    for lhs, productions in grammar.items():
        for production in productions:
            first_set = set()
            
            for symbol in production:
                first_set.update(first[symbol] - {'ε'})
                if 'ε' not in first[symbol]:
                    break
            else:
                first_set.add('ε')

            for terminal in first_set - {'ε'}:
                table[lhs][terminal] = production

            if 'ε' in first_set:
                for terminal in follow[lhs]:
                    table[lhs][terminal] = production

    return table

def print_ll1_table(table):
    terminals = sorted({t for row in table.values() for t in row.keys()})
    header = ["Non-Terminal"] + terminals
    print(f"{header[0]:<15} {' | '.join(f'{h:<10}' for h in header[1:])}")
    print("=" * (15 + 12 * len(terminals)))

    for non_terminal, row in table.items():
        row_str = [row.get(t, "") for t in terminals]
        print(f"{non_terminal:<15} {' | '.join(f'{r:<10}' for r in row_str)}")

def get_user_input():
    grammar = {}
    print("Enter the grammar productions (one per line). Use 'ε' for epsilon. Enter a blank line to finish.")
    while True:
        line = input().strip()
        if not line:
            break
        lhs, rhs = line.split('->')
        lhs = lhs.strip()
        rhs = [prod.strip() for prod in rhs.split('|')]
        grammar[lhs] = rhs
    
    start_symbol = input("Enter the start symbol: ").strip()
    return grammar, start_symbol

# Get user input
grammar, start_symbol = get_user_input()

# Compute FIRST, FOLLOW, and LL(1) table
first_sets = compute_first(grammar)
follow_sets = compute_follow(grammar, start_symbol, first_sets)
ll1_table = construct_ll1_table(grammar, first_sets, follow_sets)

# Display Results
print("\nFIRST sets:")
for nt, fset in first_sets.items():
    print(f"FIRST({nt}) = {fset}")

print("\nFOLLOW sets:")
for nt, fset in follow_sets.items():
    print(f"FOLLOW({nt}) = {fset}")

print("\nLL(1) Parsing Table:")
print_ll1_table(ll1_table)
----------------------------------------------------------------------------------------------------------------------

from collections import defaultdict

def compute_first():
    while True:
        changed = False
        for nt in rules:
            for prod in rules[nt]:
                tokens = prod.split()
                temp = set()

                for tok in tokens:
                    temp.update(first[tok])
                    if "ε" not in first[tok]:  
                        break
                else:
                    temp.add("ε")

                if temp - first[nt]:  
                    first[nt].update(temp)
                    changed = True
        if not changed:
            break

def compute_follow():
    follow[start_symbol].add("$")
    
    while True:
        changed = False
        for nt in rules:
            for prod in rules[nt]:
                tokens = prod.split()
                for i, tok in enumerate(tokens):
                    if tok in rules:
                        temp = set()
                        for next_tok in tokens[i+1:]:
                            temp.update(first[next_tok])
                            if "ε" not in first[next_tok]:
                                break
                        else:
                            temp.update(follow[nt])
                        
                        temp.discard("ε")
                        if temp - follow[tok]:  
                            follow[tok].update(temp)
                            changed = True
        if not changed:
            break

def build_parsing_table():
    for nt in rules:
        for prod in rules[nt]:
            tokens = prod.split()
            first_set = set()
            
            for tok in tokens:
                first_set.update(first[tok])
                if "ε" not in first[tok]:
                    break
            else:
                first_set.add("ε")

            for terminal in first_set - {"ε"}:
                parsing_table[nt][terminal] = prod
            
            if "ε" in first_set:
                for terminal in follow[nt]:
                    parsing_table[nt][terminal] = "ε"

def print_parsing_table():
    print("\nLL(1) Parsing Table:")
    print("-" * (20 + len(terminals) * 15))
    print(f"{'Non-Terminal':<20}", end="")
    for term in terminals:
        print(f"{term:<15}", end="")
    print("\n" + "-" * (20 + len(terminals) * 15))

    for nt in non_terminals:
        print(f"{nt:<20}", end="")
        for term in terminals:
            print(f"{parsing_table[nt].get(term, ''):<15}", end="")
        print()
    print("-" * (20 + len(terminals) * 15))

def parse_string(input_string):
    stack = [start_symbol, "$"]
    input_string += " $"
    tokens = input_string.split()

    print("\nParsing Steps:")
    print("-" * 50)
    print(f"{'Stack':<20}{'Input':<20}{'Action'}")
    print("-" * 50)

    index = 0
    while stack:
        top = stack[-1]
        current_token = tokens[index]

        print(f"{' '.join(stack):<20}{' '.join(tokens[index:]):<20}", end="")

        if top == current_token:  
            stack.pop()
            index += 1
            print(f"Match {current_token}")
        elif top in parsing_table and current_token in parsing_table[top]:  
            stack.pop()
            production = parsing_table[top][current_token]
            if production != "ε":
                stack.extend(reversed(production.split()))
            print(f"Apply {top} -> {production}")
        else:  
            print("Error! String rejected.")
            print("\n❌ Invalid String! It does NOT belong to the grammar.")
            return False

    if stack == ["$"] and index == len(tokens) - 1:
        print("\n✅ Valid String! It belongs to the grammar.")
        return True
    else:
        print("\n❌ Invalid String! It does NOT belong to the grammar.")
        return False

# ---------- Main Program ---------- #

rules = defaultdict(list)
first = defaultdict(set)
follow = defaultdict(set)
parsing_table = defaultdict(dict)

# User Inputs
terminals = input("Enter terminals (space-separated): ").split()
non_terminals = input("Enter non-terminals (space-separated): ").split()
start_symbol = non_terminals[0]

print("Enter productions (format: A -> alpha | beta), type 'done' to stop:")
while True:
    inp = input().strip()
    if inp.lower() == "done":
        break
    head, body = inp.split("->")
    rules[head.strip()] = [p.strip() for p in body.split("|")]

# Initialize FIRST sets
for t in terminals:
    first[t] = {t}
for nt in non_terminals:
    first[nt] = set()

compute_first()
compute_follow()
build_parsing_table()
print_parsing_table()

# Parsing Input String
input_string = input("\nEnter input string to parse: ")
parse_string(input_string)

----------------------------------------------------------------------------------------------------------------

Lex:
%{
#include<stdio.h>
%}
%%
"\n"|"\t"|" " {printf("\nWhite Space");}
#.* {printf("\n%s - preprocessor directive",yytext);}
int|float|double|char|while|for|if|else|scanf|printf|main|getch {printf("\n%s-keyword",yytext);}
"++"|"--" {printf("\n%s - unary operator",yytext);}
"+"|"-"|"*"|"/"|"%" {printf("\n%s - Arithmetic Operator",yytext);}
"<"|">"|"<="|">="|"==" {printf("\n%s - Relational Operator",yytext);}
"&&"|"||"|"!" {printf("\n%s - Logical Operator",yytext);}
"="|"+="|"-="|"*=" {printf("\n%s - Assignment Operator",yytext);}
[a-zA-Z_]([a-zA-Z0-9_])* {printf("\n%s - Identifier",yytext);}
[0-9]+ {printf("\n%s - digit",yytext);}
"{" {printf("\n%s - block begins",yytext);}
"}" {printf("\n%s - block exits",yytext);}
[();,] {printf("\n%s - separator",yytext);}
\".*\" {printf("\n%s - String",yytext);}
%%
int yywrap()
{}
int main(int argc,char **argv)
{
if(argc>1)
{
FILE *file;
file=fopen(argv[1],"r");
if(!file)
{
printf("Couldn't Open File %s",argv[1]);
exit(0);
}
yyin=file;
}
yylex();
return 0;
}
input.c:
#include<stdio.h>
int main()
{
int fact=1,n=5;
for(int i=1;i<=n;i++)
{
fact=fact*i;
}
printf("Factorial of 5 = %d",fact);
}
----------------------------------------------------------------------------------------------------------------------------------
Lex :
alpha [A-Za-z]
digit [0-9]
%%
[ \t\n]
if return IF;
then return THEN;
else return ELSE;
{digit}+ return NUM;
{alpha}({alpha}|{digit})* return ID;
"<=" return LE;
">=" return GE;
"==" return EQ;
"!=" return NE;
"||" return OR;
"&&" return AND;
. return yytext[0];
%%
Yacc:
%{
#include<stdio.h>
#include<stdlib.h>
int yylex();
int yyerror();
%}
%token ID NUM IF THEN LE GE EQ NE OR AND ELSE
%right '='
%left AND OR
%left '<' '>' LE GE EQ NE
%left '+' '-'
%left '*' '/'
%right UMINUS
%left '!'
%%
S :ST {printf("Input Accepted.\n");exit(0);};
ST :IF '(' E2 ')' THEN ST1 ';' ELSE ST1 ';'
|IF '(' E2 ')' THEN ST1 ';'
;
ST1 :ST
|E
;
E :ID '=' E
|E '+' E
|E '-' E
|E '*' E
|E '/' E
|E '<' E
|E '>' E
|E LE E
|E GE E
|E EQ E
|E NE E
|E OR E
|E AND E
|ID
|NUM
;
E2 :E '<' E
|E '>' E
|E LE E
|E GE E
|E EQ E
|E NE E
|E OR E
|E AND E
|ID
|NUM
;
%%
#include "lex.yy.c"
int main(){
printf("Enter the Expression : ");
yyparse();
return 0;
}

----------------------------------------------------------------------------------------------------------------------------------------------
lex:
%%
[ \n\t] ;
for return FOR;
while return WHILE;
[a-zA-Z_]([a-zA-Z_])* return ID;
[0-9]+ return DIGIT;
"<=" return LE;
">=" return GE;
"==" return EQ;
. return yytext[0];
%%
int yywrap()
{
return 1;
}
yacc:
%{
#include<stdio.h>
%}
%token FOR WHILE ID DIGIT LE GE EQ
%right '='
%left '<''>'LE GE EQ
%left '+''-'
%%
S :ST{printf("Input Accepted");exit(0);};
ST :FOR'('E';'E2';'E')'DEF
|WHILE'('E')'DEF
;
DEF:'{'BODY'}'
|ST
|E';'
|';'
;
BODY :BODY BODY
|ST
|E';'
|
;
E :ID'='E
|E'+'E
|E'-'E
|E'*'E
|E'/'E
|E'>'E
|E'<'E
|E LE E
|E GE E
|E EQ E
|E'+''+'
|E'-''-'
|DIGIT
|ID
;
E2 :E'>'E
|E'<'E
|E LE E
|E GE E
|E EQ E
;
%%
#include "lex.yy.c"
int main()
{
printf("Enter expression:\n");
yyparse();
}
yyerror()
{
printf("invalid expression");
}

------------------------------------------------------------------------------------------------------------------------------

lex:
%%
[\n \t] ;
int|float|char|double return TYPE;
return return RETURN;
[0-9]+ return NUM;
[a-zA-Z_]([a-zA-Z0-9_])* return ID;
. return yytext[0];
%%
yacc:
%{
#include<stdio.h>
%}
%token NUM ID TYPE RETURN
%right '='
%left '+''-'
%left '*''/'
%%
S :FUN{printf("Input Accepted/n");exit(0);};
FUN :TYPE ID'('PARAM')''{'BODY'}';
PARAM :PARAM','TYPE ID
|TYPE ID
|TYPE ID'='NUM
|TYPE ID'['']'
|
;
BODY :BODY BODY
|PARAM';'
|RETURN E';'
|
;
E :ID'='E
|E'+'E
|E'-'E
|E'*'E
|E'/'E
|ID'['NUM']''='E
|ID'['NUM']'
|NUM
|ID
;
%%
#include "lex.yy.c"
main()
{
printf("Enter Expression : ");
yyparse();
}
------------------------------------------------------------------------------------------------------------------------------------

%{
#include "y.tab.h"
%}

alpha [a-zA-Z]
digit [0-9]

%%
[ \t\n]         /* ignore whitespace */
switch          return SWITCH;
case            return CASE;
default         return DEFAULT;
break           return BREAK;
{digit}+        { yylval = atoi(yytext); return NUM; }
{alpha}({alpha}|{digit})* return ID;

.               return yytext[0];
%%

%{
#include <stdio.h>
#include <stdlib.h>
int yylex();
void yyerror(const char *s);
%}

%token SWITCH CASE DEFAULT BREAK ID NUM

%%

switch_statement : SWITCH '(' ID ')' '{' case_list '}'
                 ;

case_list : case_item
          | case_list case_item
          ;

case_item : CASE NUM ':' statement_list BREAK ';'
          | DEFAULT ':' statement_list BREAK ';'
          ;

statement_list : statement
               | statement_list statement
               ;

statement : ID '=' expression ';'
          | /* empty */
          ;

expression : NUM
           | ID
           | expression '+' expression
           | expression '-' expression
           | expression '*' expression
           | expression '/' expression
           ;

%%

void yyerror(const char *s) {
    fprintf(stderr, "Error: %s\n", s);
}

int main() {
    printf("Enter a switch statement: \n");
    yyparse();
    printf("Valid switch statement\n");
    return 0;
}

